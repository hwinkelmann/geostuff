<!DOCTYPE html>
<html>
    <body style="position: absolute; inset: 0; margin: 0; overflow: hidden;">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>

        <script type="text/javascript">
            // https://engineering.monstar-lab.com/en/post/2022/03/01/Introduction-To-GPUs-With-OpenGL/
            const canvas = document.createElement("canvas");
            canvas.width = document.body.clientWidth;
            canvas.height = document.body.clientHeight;
            document.body.appendChild(canvas);

            const gl = canvas.getContext("webgl");
            if (!gl) {
                throw new Error('Unable to use WebGL. Your device may not support it.');
            }

            // Vertex shader
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, `
                uniform float scale;

                attribute vec2 position;
                attribute vec3 color;

                uniform mat4 projectionMatrix;
                uniform mat4 modelViewMatrix;

                varying mediump vec3 vColor;

                void main(void) {
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position * scale, 0.1, 1.0);
                    vColor = color;
                }
            `);
            gl.compileShader(vertexShader);

            // Error handling only
            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                throw new Error(gl.getShaderInfoLog(vertexShader));
            }

            // Fragment shader
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, `
                varying mediump vec3 vColor;

                void main(void) {
                    gl_FragColor = vec4(vColor, 1.0);
                }
            `);
            gl.compileShader(fragmentShader);

            // Error handling only
            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                throw new Error(gl.getShaderInfoLog(fragmentShader));
            }

            const texture = loadTexture(gl, "./wood.png");

            // Bundle things up in a program
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            gl.useProgram(program);

            let rot = 0;
            const handler = (time) => {
                render(rot);
                rot = time / 1000;
                requestAnimationFrame(handler);
            };

            requestAnimationFrame(handler);

            function render(rotX) {
                gl.clearColor(0, 0.5, 1, 1);
                gl.clearDepth(1);
                gl.enable(gl.DEPTH_TEST); // Enable depth testing
                gl.depthFunc(gl.LEQUAL); // Near things obscure far things
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                // Initialize projection matrix
                const fieldOfView = (45 * Math.PI) / 180; // in radians
                const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
                const zNear = 0.1;
                const zFar = 100.0;
                const projectionMatrix = mat4.create();

                // note: glmatrix.js always has the first argument
                // as the destination to receive the result.
                mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);

                const modelViewMatrix = mat4.create();
                mat4.translate(modelViewMatrix, modelViewMatrix, [-0.0, 0.0, -1.0]);
                mat4.rotate(modelViewMatrix, modelViewMatrix, rotX, [1, 0, 0])

                // Set uniforms
                const scaleUniform = gl.getUniformLocation(program, "scale");
                gl.uniform1f(scaleUniform, 1);

                const projectionMatrixLocation = gl.getUniformLocation(program, "projectionMatrix");
                gl.uniformMatrix4fv(projectionMatrixLocation, false, projectionMatrix);

                const modelViewMatrixLocation = gl.getUniformLocation(program, "modelViewMatrix");
                gl.uniformMatrix4fv(modelViewMatrixLocation, false, modelViewMatrix);

                // Create vertex buffer
                const positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                    -1, -1, // A
                    +1, -1, // B
                    +1, +1, // C
                    -1, -1, // A
                    -1, +1, // D
                ]), gl.STATIC_DRAW);

                // Set format of currently bound buffer
                const positionAttribute = gl.getAttribLocation(program, "position");
                gl.enableVertexAttribArray(positionAttribute);
                gl.vertexAttribPointer(positionAttribute, 2, gl.FLOAT, false, 0, 0);

                // Create color buffer
                const colorBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                    1, 0, 0, // A = red
                    0, 1, 0, // B = green
                    0, 0, 1, // C = blue
                    1, 0, 0, // A = red
                    1, 1, 0, // D = yellow
                ]), gl.STATIC_DRAW);

                const colorAttribute = gl.getAttribLocation(program, "color");
                gl.enableVertexAttribArray(colorAttribute);
                gl.vertexAttribPointer(colorAttribute, 3, gl.FLOAT, false, 0, 0);

                

                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 5);
            }

            //
            // Initialize a texture and load an image.
            // When the image finished loading copy it into the texture.
            //
            function loadTexture(gl, url) {
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);

                // Because images have to be downloaded over the internet
                // they might take a moment until they are ready.
                // Until then put a single pixel in the texture so we can
                // use it immediately. When the image has finished downloading
                // we'll update the texture with the contents of the image.
                const level = 0;
                const internalFormat = gl.RGBA;
                const width = 1;
                const height = 1;
                const border = 0;
                const srcFormat = gl.RGBA;
                const srcType = gl.UNSIGNED_BYTE;
                const pixel = new Uint8Array([0, 0, 255, 255]); // opaque blue
                gl.texImage2D(
                    gl.TEXTURE_2D,
                    level,
                    internalFormat,
                    width,
                    height,
                    border,
                    srcFormat,
                    srcType,
                    pixel
                );

                const image = new Image();
                    image.onload = () => {
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(
                    gl.TEXTURE_2D,
                    level,
                    internalFormat,
                    srcFormat,
                    srcType,
                    image
                );

                // WebGL1 has different requirements for power of 2 images
                // vs. non power of 2 images so check if the image is a
                // power of 2 in both dimensions.
                if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
                    // Yes, it's a power of 2. Generate mips.
                    gl.generateMipmap(gl.TEXTURE_2D);
                } else {
                    // No, it's not a power of 2. Turn off mips and set
                    // wrapping to clamp to edge
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                }
                };
                image.src = url;

                return texture;
            }

            function isPowerOf2(value) {
                return (value & (value - 1)) === 0;
            }
</script>
    </body>
</html> 